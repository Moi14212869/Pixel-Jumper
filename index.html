<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" href="favicon.ico" type="image/x-icon">
        <title>Jumpix</title>
        <style>
			body {
				margin: 0;
				background-color: #3d2505;
			}
			canvas {
				display: block;
				margin: 75px auto;
			}
		</style>
        <script src="phaser.min.js"></script>
    </head>
    <body>


        <script>
		/* =========================================================
                    FONCTIONS COMMUNES
========================================================= */
let gameVolume = parseFloat(localStorage.getItem("gameVolume"));
if (isNaN(gameVolume)) gameVolume = 0.5;
let playerCoins = parseInt(localStorage.getItem("playerCoins")) || 0;
let dead = parseInt(localStorage.getItem("dead")) || 0;
let kill = parseInt(localStorage.getItem("kill")) || 0;
let party = parseInt(localStorage.getItem("party")) || 0;
let colorPlayer = parseInt(localStorage.getItem("colorPlayer")) || 0xAA66CC;
function createPlatform(scene, x, y, widthInPx, heightInPx = 40, color = 0xA0522D) {
    const tileSize = 40;
    const blocksPerRow = Math.floor(widthInPx / tileSize);
    const blocksPerCol = Math.floor(heightInPx / tileSize);

    for (let row = 0; row < blocksPerCol; row++) {
        for (let col = 0; col < blocksPerRow; col++) {
            const gfx = scene.add.graphics();
            gfx.fillStyle(color, 1);
            gfx.fillRect(0, 0, tileSize, tileSize);

            const key = `block-${x + col * tileSize}-${y + row * tileSize}`;
            gfx.generateTexture(key, tileSize, tileSize);
            gfx.destroy();

            const block = scene.platforms.create(x + col * tileSize, y + row * tileSize, key);
            block.setOrigin(0, 0);
            block.refreshBody();
        }
    }
}

function createBlueCircle(scene, x, y) {
    const radius = 20;
    const gfx = scene.add.graphics();
    gfx.fillStyle(0x0000FF, 1);
    gfx.fillCircle(radius, radius, radius);

    const key = `blueCircle-${x}-${y}`;
    gfx.generateTexture(key, radius * 2, radius * 2);
    gfx.destroy();

    const circle = scene.physics.add.sprite(x, y, key);
    circle.setCircle(radius);
    circle.setOrigin(0.5);
    circle.body.allowGravity = false;

    scene.tweens.add({
        targets: circle,
        y: circle.y - 5,
        duration: 800,
        yoyo: true,
        repeat: -1,
        ease: "Sine.easeInOut"
    });

    return circle;
}

function createRedTriangle(scene, x, y, orientation = 'up') {
    const size = 40;
    const height = Math.sqrt(3) / 2 * size;
    const key = `triangle-${x}-${y}-${orientation}`;

    const gfx = scene.add.graphics();
    gfx.fillStyle(0xFF0000, 1);
    gfx.beginPath();

    if (orientation === 'up') { gfx.moveTo(size / 2, 0); gfx.lineTo(0, height); gfx.lineTo(size, height); }
    else if (orientation === 'down') { gfx.moveTo(size / 2, height); gfx.lineTo(0, 0); gfx.lineTo(size, 0); }
    else if (orientation === 'left') { gfx.moveTo(0, size / 2); gfx.lineTo(height, 0); gfx.lineTo(height, size); }
    else if (orientation === 'right') { gfx.moveTo(height, size / 2); gfx.lineTo(0, 0); gfx.lineTo(0, size); }

    gfx.closePath();
    gfx.fillPath();

    if (orientation === 'left' || orientation === 'right') gfx.generateTexture(key, height, size);
    else gfx.generateTexture(key, size, height);
    gfx.destroy();

    const triangle = scene.spikes.create(x, y, key);

    switch (orientation) {
        case 'up': triangle.setOrigin(0.5, 1); break;
        case 'down': triangle.setOrigin(0.5, 0); break;
        case 'left': triangle.setOrigin(1, 0.5); break;
        case 'right': triangle.setOrigin(0, 0.5); break;
    }

    triangle.refreshBody();

    const body = triangle.body;
    const bodyWidth = body.width * 0.7;
    const bodyHeight = body.height * 0.7;
    const offsetX = (body.width - bodyWidth) / 2;
    const offsetY = (body.height - bodyHeight) / 2;

    body.setSize(bodyWidth, bodyHeight);
    body.setOffset(offsetX, offsetY);

    return triangle;
}

function createMobileControls(scene) {

  // ‚ùå PC = pas de boutons
  if (!scene.sys.game.device.input.touch) return;

  scene.movingLeft = false;
  scene.movingRight = false;

  const createButtons = () => {

    const { width, height } = scene.scale;

    // Supprimer anciens boutons (resize)
    if (scene.leftBtn) {
      scene.leftBtn.destroy();
      scene.rightBtn.destroy();
      scene.jumpBtn.destroy();
    }

    // Tailles dynamiques
    const btnSize = Math.max(48, width * 0.08);
    const padding = btnSize * 0.4;
    const margin = width * 0.05;

    const btnStyle = {
      fontSize: `${btnSize}px`,
      color: "#ffffff",
      backgroundColor: "#00BFFF",
      padding: { x: padding, y: padding * 0.6 },
      borderRadius: 20
    };

    // Cr√©ation boutons
    scene.leftBtn = scene.add.text(
      margin,
      height - btnSize * 2,
      "‚óÄ",
      btnStyle
    ).setInteractive();

    scene.rightBtn = scene.add.text(
      margin + btnSize * 1.4,
      height - btnSize * 2,
      "‚ñ∂",
      btnStyle
    ).setInteractive();

    scene.jumpBtn = scene.add.text(
      width - margin - btnSize,
      height - btnSize * 2,
      "‚¨Ü",
      btnStyle
    ).setInteractive();

    // Propri√©t√©s communes
    [scene.leftBtn, scene.rightBtn, scene.jumpBtn].forEach(btn => {
      btn.setAlpha(0.6);
      btn.setScrollFactor(0);

      // ‚ú® ANIMATION D‚ÄôAPPUI
      btn.on('pointerdown', () => btn.setAlpha(0.9));
      btn.on('pointerup', () => btn.setAlpha(0.6));
      btn.on('pointerout', () => btn.setAlpha(0.6));
    });

    // D√©placements
    scene.leftBtn.on('pointerdown', () => scene.movingLeft = true);
    scene.leftBtn.on('pointerup', () => scene.movingLeft = false);
    scene.leftBtn.on('pointerout', () => scene.movingLeft = false);

    scene.rightBtn.on('pointerdown', () => scene.movingRight = true);
    scene.rightBtn.on('pointerup', () => scene.movingRight = false);
    scene.rightBtn.on('pointerout', () => scene.movingRight = false);

    // Saut
    scene.jumpBtn.on('pointerdown', () => scene.jumpPlayer());
  };

  // Cr√©ation initiale
  createButtons();

  // üîÅ Auto-resize √©cran / rotation
  scene.scale.on('resize', createButtons);
}
/* =========================================================
                    LOADING SCENE
========================================================= */
class LoadingScene extends Phaser.Scene {
    constructor() {
        super("LoadingScene");
    }

    preload() {
        const { width, height } = this.scale;

        // Texte "Chargement..."
        const loadingText = this.add.text(width / 2, height / 2 - 50, "Chargement...", {
            fontSize: "32px",
            fill: "#ffffff"
        }).setOrigin(0.5);

        // Barre de fond
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(width / 2 - 160, height / 2, 320, 30);

        // Barre de progression
        const progressBar = this.add.graphics();

        // Pourcentage
        const percentText = this.add.text(width / 2, height / 2 + 50, "0%", {
            fontSize: "20px",
            fill: "#ffffff"
        }).setOrigin(0.5);

        // √âv√©nement de progression
        this.load.on('progress', (value) => {
            progressBar.clear();
            progressBar.fillStyle(0xffffff, 1);
            progressBar.fillRect(width / 2 - 150, height / 2 + 5, 300 * value, 20);
            percentText.setText(parseInt(value * 100) + "%");
        });
		this.load.audio('bgm', 'asset/8bit-music-for-game-68698.mp3');
		this.load.audio('jump', 'asset/jump_c_02-102843.mp3');
		this.load.audio('dead', 'asset/game-over-arcade-6435.mp3');
		this.load.audio('victory', 'asset/level-up-enhancement-8-bit-retro-sound-effect-153002.mp3');
		this.load.audio('menu', 'asset/menu.mp3');
		this.load.audio('select', 'asset/select.mp3');
		this.load.audio('kill', 'asset/kill.mp3');
		this.load.audio('buy', 'asset/buy.mp3');
        // Quand le chargement est complet
        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.setText("Pr√™t !");
            percentText.destroy();
        });
	}
		 create() {
        // Lancement du menu apr√®s un petit d√©lai
		this.bgm = this.sound.add('bgm', { loop: true, volume: gameVolume });
        this.time.delayedCall(500, () => {
			if (!this.bgm.isPlaying) this.bgm.play();
            this.scene.start("MenuScene");
        });
    }
}



/* =========================================================
                        MENU SCENE
========================================================= */

class MenuScene extends Phaser.Scene {
    constructor() {
        super("MenuScene");
    }

    create() {
		
        const title = this.add.text(400, 120, "Jumpix", {
            fontSize: "50px",
            color: "#ffffffff"
        }).setOrigin(0.5);
		this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite
		
const setting = this.add.text(5, 5, "‚öô", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        setting.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("SettingsScene");
        });
        const niveaux = [
            { nom: "Shop üõí", scene: "ShopScene" },
			{ nom: "Statistics", scene: "Stats" },
			{ nom: "‚û° Play !!", scene: "World1" },
			{ nom: "Credits", scene: "CreditsScene" }
        ];

        let yPos = 260;
        niveaux.forEach(niv => {
            const btn = this.add.text(400, yPos, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start(niv.scene);
			})
            yPos += 60; // √©cart vertical entre boutons
        });
    }
}
function createRedCircle(scene, x, y, riseAmount = 100, direction = 'up') {
  const radius = 10;

  const gfx = scene.add.graphics();
  gfx.fillStyle(0xFF0000, 1);
  gfx.fillCircle(radius, radius, radius);
  const key = `redCircle-${x}-${y}`;
  gfx.generateTexture(key, radius * 2, radius * 2);
  gfx.destroy();

  const circle = scene.physics.add.sprite(x, y, key);
  circle.setCircle(radius);
  circle.setOrigin(0.5);
  circle.body.moves = false;
  circle.body.allowGravity = false;
  circle.body.immovable = true;

  const targetY = direction === 'up' ? y - riseAmount : y + riseAmount;

  scene.tweens.add({
    targets: circle,
    y: targetY,
    duration: 2000,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut'
  });

  return circle;
}
function createRedSquare(x, y, scene, distance = 100, direction = 'right') {
  const size = 40;

  // Dessin du carr√© rouge
  const gfx = scene.add.graphics();
  gfx.fillStyle(0xFF0000, 1);
  gfx.fillRect(0, 0, size, size);

  const key = `redSquare-${x}-${y}-${direction}`;
  gfx.generateTexture(key, size, size);
  gfx.destroy();

  const square = scene.physics.add.sprite(x, y, key);
  square.setSize(size, size);
  square.setOrigin(0.5);
  square.body.allowGravity = false;
  square.body.immovable = true;

  // Animation horizontale
  let targetX = x;

  if (direction === 'right') {
    targetX = x + distance;
  } else if (direction === 'left') {
    targetX = x - distance;
  } else {
    console.warn('Direction inconnue pour redSquare :', direction);
  }
  scene.tweens.add({
    targets: square,
    x: targetX,
    duration: 2000,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut'
  });

  return square;
}
/* =========================================================
                        LEVEL
========================================================= */
class LevelScene extends Phaser.Scene {
  constructor() {
    super("LevelScene");
  }

  init(data) {
    this.levelKey = data.levelKey; // ex: "world1_level1"
  }

preload() {
  this.load.json(this.levelKey, `levels/${this.levelKey}.json`);
}


  create() {
const level = this.cache.json.get(this.levelKey);


    this.transitioning = false;
    this.platforms = this.physics.add.staticGroup();
    this.spikes = this.physics.add.staticGroup();
    this.redCircles = this.physics.add.group();
	this.redSquares = this.physics.add.group();

    this.input.addPointer(2);
    this.cursors = this.input.keyboard.createCursorKeys();
    this.jumpCount = 0;

    // --- PLATEFORMES ---
    level.platforms.forEach(p => {
	  const color = typeof p.color === "string" ? parseInt(p.color) : (p.color || 0xA0522D);
      createPlatform(this, p.x, p.y, p.w, p.h || 40, color || 0xA0522D)
	});

    // --- PIQUES ---
    level.spikes.forEach(s =>
      createRedTriangle(this, s.x, s.y, s.orientation || "up")
    );

    // --- BOULES ROUGES ---
    if (level.redCircles) {
      level.redCircles.forEach(c =>
        this.redCircles.add(createRedCircle(
          this,
          c.x,
          c.y,
          c.rise,
          c.direction || "up"
        ))
      );
    }
    // --- CARRES ---
	if (level.redSquares) {
      level.redSquares.forEach(r =>
        this.redSquares.add(createRedSquare(
          r.x,
          r.y,
		  this,
          r.rise,
          r.direction
        ))
      );
    }
    // --- JOUEUR ---
    const size = 40;
    const gfx = this.add.graphics();
    gfx.fillStyle(colorPlayer, 1);
    gfx.fillRect(0, 0, size, size);
    gfx.generateTexture("player", size, size);
    gfx.destroy();

    this.player = this.physics.add.sprite(
      level.playerStart.x,
      level.playerStart.y,
      "player"
    );

    this.player.setBounce(0.2).setCollideWorldBounds(true);

    // --- SORTIE ---
    this.blueCircle = createBlueCircle(
      this,
      level.blueCircle.x,
      level.blueCircle.y
    );
	// --- Bouton "Retour" ---
const backButton = this.add.text(5, 5, "‚Üê", {
    fontSize: "24px",
    color: "#ffffff",
    backgroundColor: "#00BFFF",
    padding: { x: 7, y: 4 },
    borderRadius: 5
}).setInteractive();

// √âv√©nement au clic sur le bouton
backButton.on("pointerdown", () => {
    // Jouer le son du menu
    this.sound.play('menu', { volume: gameVolume });

    // Retour √† la sc√®ne "World1"
    this.scene.start(level.nextScene);
});

    // --- COLLISIONS ---
    this.physics.add.collider(this.player, this.platforms);
	this.physics.add.collider(this.redSquares, this.platforms);
    this.physics.add.collider(this.player, this.spikes, () => this.die());
    this.physics.add.overlap(this.player, this.redCircles, () => this.die());
	this.physics.add.overlap(this.player, this.redSquares, (player, square) => {
  const playerBottom = player.y + player.displayHeight / 2;
  const squareTop = square.y - square.displayHeight / 2;

  const verticalDiff = playerBottom - squareTop;

  // Si le joueur touche par le haut (avec une petite marge de tol√©rance)
  if (verticalDiff < 10 && player.body.velocity.y > 0) {
    // Le joueur a saut√© sur le carr√© rouge
	kill++;
	localStorage.setItem("kill", kill);
	this.sound.play("kill", { volume: gameVolume });
    player.setVelocityY(-200);
    this.tweens.add({
      targets: square,
      scaleX: 0,
      scaleY: 0,
      duration: 300,
      ease: 'Cubic.easeIn',
      onComplete: () => {
        square.destroy();
      }
    });
    } else {
	  dead++;
	localStorage.setItem("dead", dead);
    this.sound.play("dead", { volume: gameVolume });
    this.scene.restart();
  }
  }, null, this);

	this.physics.add.overlap(this.player, this.blueCircle, () => {
    // Jouer le son de victoire
    this.sound.play('victory', { volume: gameVolume });
	party++;
	localStorage.setItem("party", party);
    // V√©rifier si une transition est d√©j√† en cours
    if (this.transitioning) return;
    this.transitioning = true;

    // D√©sactiver le mouvement du joueur
    this.player.body.enable = false;

    // D√©finir la position cible pour l'animation
    const targetX = this.blueCircle.x;
    const targetY = this.blueCircle.y;

    // Ajouter l'animation de transition du joueur
    this.tweens.add({
        targets: this.player,
        x: targetX,
        y: targetY,
        scale: 0.3,
        angle: 720,
        duration: 800,
        ease: 'Cubic.easeInOut',
        onComplete: () => {


            // Ajouter des pi√®ces au joueur
            playerCoins += level.reward || 0;
            localStorage.setItem("playerCoins", playerCoins);
            // Changer de sc√®ne
            this.scene.start(level.nextScene);
        }
    });
}, null, this);
    createMobileControls(this);
  }

  die() {
    this.sound.play("dead", { volume: gameVolume });
	dead++;
	localStorage.setItem("dead", dead);
    this.scene.restart({ levelKey: this.levelKey });
  }

update() {
    const p = this.player;

    // --- D√©placement horizontal ---
    if (this.cursors.left.isDown || this.movingLeft) {
        p.setVelocityX(-160);
    } else if (this.cursors.right.isDown || this.movingRight) {
        p.setVelocityX(160);
    } else {
        p.setVelocityX(0);
    }

    // --- Reset compteur de saut si le joueur touche le sol ---
    if (p.body.touching.down) {
        this.jumpCount = 0;
    }

    // --- Saut via clavier ---
    if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {
        this.jumpPlayer();
    }
}

// --- Fonction saut + double saut ---
jumpPlayer() {
    if (this.jumpCount < 2) {
        // Appliquer la v√©locit√© verticale pour le saut
        this.player.setVelocityY(-330);

        // Si c'est le deuxi√®me saut, ajouter une rotation
        if (this.jumpCount === 1) {
            const dir = this.cursors.left.isDown ? -1 : (this.cursors.right.isDown ? 1 : 1);

            this.tweens.add({
                targets: this.player,
                angle: this.player.angle + 180 * dir,
                duration: 500,
                ease: "Cubic.easeOut"
            });
        }

        // Jouer le son du saut
        this.sound.play('jump', { volume: gameVolume });

        // Incr√©menter le compteur de saut
        this.jumpCount++;
    }
}
}
/* =====================================================
                    Shop
   ===================================================== */
function normalizeKeyToHex(key) {
    if (typeof key === "number") {
        return key.toString(16).toUpperCase().padStart(6, "0");
    }

    key = String(key).trim();

    if (key.startsWith("0x") || key.startsWith("0X")) key = key.slice(2);
    if (key.startsWith("#")) key = key.slice(1);

    return key.toUpperCase();
}

// ----------- SHOP SCENE -----------
class ShopScene extends Phaser.Scene {
    constructor() {
        super("ShopScene");
    }

    preload() {}

    create() {

        this.add.text(360, 20, "SHOP", { fontSize: "40px", fill: "#ffffff" });
       this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite

        const ITEMS = [
            { key: "AA66CC", label: "Purple", price: 0 },
            { key: "73BE73", label: "Green", price: 50 },
            { key: "CC99A2", label: "Pink", price: 100 },
			{ key: "40E0D0", label: "Turquoise", price: 150 },
			{ key: "FFA500", label: "Orange", price: 200 }
        ];

        let startY = 150;

        ITEMS.forEach(item => {
            const hexKey = normalizeKeyToHex(item.key);
            const bought = localStorage.getItem("skin_" + hexKey) === "1";
			const isSelected = parseInt(localStorage.getItem("colorPlayer")) === parseInt("0x" + hexKey);

            this.add.rectangle(80, startY, 50, 50, parseInt("0x" + hexKey));

            this.add.text(140, startY - 20, item.label, { fontSize: "24px", fill: "#ffffff" });

            if (!bought && item.price > 0) {
                const buyText = this.add.text(350, startY - 20, "Buy " + item.price + " ‚¨°", { fontSize: "22px", fill: "#00FFFF" });
                buyText.setInteractive();

                buyText.on("pointerdown", () => {
					this.sound.play('buy', { volume: gameVolume })
					this.buySkin(hexKey, item.price);
				})
            }

            if (bought || item.price === 0) {
                const selectText = this.add.text(350, startY - 20, isSelected ? "selected" : "select", {
                    fontSize: "22px",
                    fill: isSelected ? "#00FF66" : "#FFFFFF"
                });
                selectText.setInteractive();

                selectText.on("pointerdown", () => {
					this.sound.play('select', { volume: gameVolume })
					this.selectSkin(hexKey);
				})
            }

            startY += 90;
        });

        const back = this.add.text(5, 5, "‚Üê", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        back.setInteractive();
        back.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
		const next = this.add.text(700, 280, "‚ñ∂", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        next.setInteractive();
        next.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("ShopScene2");
        });
    }

    buySkin(colorKey, price) {
        if (playerCoins < price) {
            alert("Pas assez de coins !");
            return;
        }

        playerCoins -= price;
        localStorage.setItem("playerCoins", playerCoins);

        localStorage.setItem("skin_" + colorKey, "1");
        this.scene.restart();
    }

selectSkin(colorKey) {
    const colorNumber = parseInt("0x" + colorKey);

    localStorage.setItem("colorPlayer", colorNumber);
    colorPlayer = colorNumber;

    this.scene.restart();
}
}
			// ----------- SHOP SCENE 2 -----------
class ShopScene2 extends Phaser.Scene {
    constructor() {
        super("ShopScene2");
    }

    preload() {}

    create() {

        this.add.text(360, 20, "SHOP", { fontSize: "40px", fill: "#ffffff" });
       this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite

        const ITEMS = [
            { key: "7A0000", label: "Maroon", price: 250 },
			{ key: "0B228A", label: "Dark Blue", price: 300 }
        ];

        let startY = 150;

        ITEMS.forEach(item => {
            const hexKey = normalizeKeyToHex(item.key);
            const bought = localStorage.getItem("skin_" + hexKey) === "1";
			const isSelected = parseInt(localStorage.getItem("colorPlayer")) === parseInt("0x" + hexKey);

            this.add.rectangle(80, startY, 50, 50, parseInt("0x" + hexKey));

            this.add.text(140, startY - 20, item.label, { fontSize: "24px", fill: "#ffffff" });

            if (!bought && item.price > 0) {
                const buyText = this.add.text(350, startY - 20, "Buy " + item.price + " ‚¨°", { fontSize: "22px", fill: "#00FFFF" });
                buyText.setInteractive();

                buyText.on("pointerdown", () => {
					this.sound.play('buy', { volume: gameVolume })
					this.buySkin(hexKey, item.price);
				})
            }

            if (bought || item.price === 0) {
                const selectText = this.add.text(350, startY - 20, isSelected ? "selected" : "select", {
                    fontSize: "22px",
                    fill: isSelected ? "#00FF66" : "#FFFFFF"
                });
                selectText.setInteractive();

                selectText.on("pointerdown", () => {
					this.sound.play('select', { volume: gameVolume })
					this.selectSkin(hexKey);
				})
            }

            startY += 90;
        });

        const back = this.add.text(5, 5, "‚Üê", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        back.setInteractive();
        back.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
		const prec = this.add.text(10, 280, "‚óÄ", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        prec.setInteractive();
        prec.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("ShopScene");
        });
    }

    buySkin(colorKey, price) {
        if (playerCoins < price) {
            alert("Pas assez de coins !");
            return;
        }

        playerCoins -= price;
        localStorage.setItem("playerCoins", playerCoins);

        localStorage.setItem("skin_" + colorKey, "1");
        this.scene.restart();
    }

selectSkin(colorKey) {
    const colorNumber = parseInt("0x" + colorKey);

    localStorage.setItem("colorPlayer", colorNumber);
    colorPlayer = colorNumber;

    this.scene.restart();
}
}
/* =========================================================
                       World 1
========================================================= */

class World1 extends Phaser.Scene {
    constructor() {
        super("World1");
    }

    create() {
		
        const title = this.add.text(400, 80, "World 1", {
            fontSize: "50px",
            color: "#ffffffff"
        }).setOrigin(0.5);
		this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite
		const MenuButton = this.add.text(5, 5, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        MenuButton.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
        const niveaux1 = [
            { nom: "‚û° Level 1", scene: "Level1" },
            { nom: "‚û° Level 2", scene: "Level2" },
            { nom: "‚û° Level 3", scene: "Level3" },
            { nom: "‚û° Level 4", scene: "Level4" }
        ];

        let yPos1 = 260;
        niveaux1.forEach(niv => {
            const btn = this.add.text(200, yPos1, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})
            yPos1 += 60; // √©cart vertical entre boutons
        });
		        const niveaux2 = [
            { nom: "‚û° Level 5", scene: "Level5" },
			{ nom: "‚û° Level 6", scene: "Level6" },
			{ nom: "‚û° Level 7", scene: "Level7" },
			{ nom: "‚û° Level 8", scene: "Level8" }
        ];

        let yPos2 = 260;
        niveaux2.forEach(niv => {
            const btn = this.add.text(550, yPos2, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})

            yPos2 += 60; // √©cart vertical entre boutons
        });
    }
}
/*======================================================
                   Setting
=======================================================*/
class SettingsScene extends Phaser.Scene {
    constructor() {
        super("SettingsScene");
    }

    create() {
        this.add.text(400, 80, "Settings", {
            fontSize: "40px",
            color: "#ffffff"
        }).setOrigin(0.5);

        this.add.text(400, 160, "Volume", {
            fontSize: "28px",
            color: "#ffffff"
        }).setOrigin(0.5);

        // Barre de fond
        const barBg = this.add.rectangle(400, 220, 300, 10, 0x555555);

        // Curseur
        const knob = this.add.circle(
            400 - 150 + gameVolume * 300,
            220,
            12,
            0xffffff
        ).setInteractive({ draggable: true });

        this.input.setDraggable(knob);

        this.input.on('drag', (pointer, obj, dragX) => {
            const minX = 400 - 150;
            const maxX = 400 + 150;

            obj.x = Phaser.Math.Clamp(dragX, minX, maxX);

            gameVolume = (obj.x - minX) / 300;
            gameVolume = Phaser.Math.Clamp(gameVolume, 0, 1);

            localStorage.setItem("gameVolume", gameVolume);

            this.sound.volume = gameVolume;
        });

        // Bouton retour
      		const backButton = this.add.text(5, 5, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        backButton.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
    })
}
}
/* =========================================================
                     Cr√©dits
========================================================= */
class CreditsScene extends Phaser.Scene {
    constructor() {
        super("CreditsScene");
    }

    create() {
        const { width, height } = this.scale;
        // Contenu des cr√©dits
        const credits = [
			"Credits",
			"",
            "A game by",
            "OneLevel Studio",
            "",
            "Producer & Lead Programmer",
            "Eliott MORBIDELLI",
            "",
            "Visual Designer",
            "Leonie MORBIDELLI",
            "",
            "Lead Level Designer",
            "Eliott MORBIDELLI",
            "",
            "Level Designers",
            "A. MORBIDELLI",
			"Alix MORBIDELLI",
            "",
            "QA Testers",
            "Maxence ROSS",
            "",
            "Thanks for playing!"
        ];

        // Cr√©er un conteneur pour tous les textes
        this.creditContainer = this.add.container(width / 2, height + 50);

        let offsetY = 0;
        credits.forEach(line => {
            const text = this.add.text(0, offsetY, line, {
                fontSize: "28px",
                color: "#ffffff"
            }).setOrigin(0.5);
            this.creditContainer.add(text);
            offsetY += 50; // espacement entre les lignes
        });

        // Vitesse de d√©filement (pixels par seconde)
        this.scrollSpeed = 50;

        // √âv√©nement clic partout sur la sc√®ne
        this.input.once('pointerdown', () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("MenuScene");
        });
    }

    update(time, delta) {
        // Faire d√©filer les cr√©dits vers le haut
        this.creditContainer.y -= this.scrollSpeed * (delta / 1000);

        // Si le dernier texte est pass√© au-dessus de l'√©cran, revenir au menu automatiquement
        const lastText = this.creditContainer.list[this.creditContainer.list.length - 1];
        if (lastText.y + this.creditContainer.y < -50) {
            this.scene.start("MenuScene");
        }
    }
}
/* ========================================================
                           Stats
========================================================= */
class Stats extends Phaser.Scene {
    constructor() {
        super("Stats");
    }

    create() {
        const { width, height } = this.scale;

        // Fond
        this.add.rectangle(width / 2, height / 2, width, height, 0x3d2505);

        // Titre
        this.add.text(width / 2, 60, "STATISTICS", {
            fontSize: "40px",
            color: "#ffffff",
            fontStyle: "bold"
        }).setOrigin(0.5);

        // R√©cup√©ration des stats
        const coins = parseInt(localStorage.getItem("playerCoins")) || 0;
        const deaths = parseInt(localStorage.getItem("dead")) || 0;
        const kills = parseInt(localStorage.getItem("kill")) || 0;
        const parties = parseInt(localStorage.getItem("party")) || 0;

        // Affichage
        const statsData = [
            { label: "Coins üí∞", value: coins },
            { label: "Deaths ‚ò†Ô∏è", value: deaths },
            { label: "Kills üî™", value: kills },
            { label: "Parties Played üéÆ", value: parties }
        ];

        let startY = 150;
        statsData.forEach(stat => {
            this.add.text(width / 2, startY, `${stat.label} : ${stat.value}`, {
                fontSize: "28px",
                color: "#ffff00"
            }).setOrigin(0.5);
            startY += 60;
        });

        // Bouton retour
        const backButton = this.add.text(10, 10, "‚Üê Back", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 10, y: 5 },
            borderRadius: 5
        }).setInteractive();

        backButton.on("pointerdown", () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("MenuScene");
        });
    }
}

/* =========================================================
                    CONFIG JEU
========================================================= */
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#ADD8E6',
  physics: { default: 'arcade', arcade: { gravity: { y: 650 }, debug: false } },
   scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
   },
  scene: [LoadingScene, MenuScene,  LevelScene, ShopScene, ShopScene2, World1, SettingsScene, CreditsScene, Stats]
};

const game = new Phaser.Game(config);
		</script>
    </body>
</html>




