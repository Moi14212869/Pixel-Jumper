<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" href="favicon.ico" type="image/x-icon">
        <title>Jumpix</title>
        <style>
			body {
				margin: 0;
				background-color: #3d2505;
			}
			canvas {
				display: block;
				margin: 75px auto;
			}
		</style>
        <script src="phaser.min.js"></script>
    </head>
    <body>


        <script>
		/* =========================================================
                    FONCTIONS COMMUNES
========================================================= */
let gameVolume = parseFloat(localStorage.getItem("gameVolume"));
if (isNaN(gameVolume)) gameVolume = 0.5;
let playerCoins = parseInt(localStorage.getItem("playerCoins")) || 0;
let dead = parseInt(localStorage.getItem("dead")) || 0;
let kill = parseInt(localStorage.getItem("kill")) || 0;
let party = parseInt(localStorage.getItem("party")) || 0;
let colorPlayer = parseInt(localStorage.getItem("colorPlayer")) || 0xAA66CC;
const DEV_PASSWORD_HASH = "9651d08ab7a975b70a93f3c918842c44cda8f335ecbbaae88d5610d3a1790b4b";
function devSetCoins(amount) {
    amount = parseInt(amount);
    if (isNaN(amount) || amount < 0) amount = 0;
    playerCoins = amount;
    localStorage.setItem("playerCoins", playerCoins);
}

function checkObjectives() {
    // D√©blocage des skins existants
    if (dead >= 1000) localStorage.setItem("skin_000000", "1");   // Noir apr√®s 1000 morts
    if (kill >= 500) localStorage.setItem("skin_FF0000", "1");   // Rouge apr√®s 500 kills
    // Nouveau : skin sp√©cial apr√®s beaucoup de parties jou√©es
    if (party >= 1000) localStorage.setItem("skin_A0522D", "1");
}
function openDevMenu() {

    // ===== OVERLAY =====
    const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.75);
    const box = this.add.rectangle(400, 300, 420, 320, 0x1c1c1c)
        .setStrokeStyle(3, 0x00ffff);

    this.add.text(400, 160, "DEV MENU", {
        fontSize: "26px",
        color: "#00ffff"
    }).setOrigin(0.5);

    // ===== INPUT COINS =====
    let coinInputValue = "";

    this.add.text(400, 200, "SET COINS", {
        fontSize: "18px",
        color: "#cccccc"
    }).setOrigin(0.5);

    const coinInputBox = this.add.rectangle(400, 240, 200, 40, 0x000000)
        .setStrokeStyle(2, 0x00ffff);

    const coinInputText = this.add.text(400, 240, "0", {
        fontSize: "22px",
        color: "#00ffcc"
    }).setOrigin(0.5);

    // ===== CLAVIER (UN SEUL) =====
    const keyboardHandler = (e) => {
        if (e.key >= "0" && e.key <= "9") {
            coinInputValue += e.key;
        }
        if (e.key === "Backspace") {
            coinInputValue = coinInputValue.slice(0, -1);
        }
        if (coinInputValue.length > 9) {
            coinInputValue = coinInputValue.slice(0, 9);
        }
        coinInputText.setText(coinInputValue || "0");
    };

    this.input.keyboard.on("keydown", keyboardHandler);

    // ===== SET COINS BUTTON =====
    const setCoins = this.add.text(400, 290, "APPLY COINS", {
        fontSize: "20px",
        backgroundColor: "#00aa00",
        color: "#ffffff",
        padding: { x: 20, y: 8 }
    }).setOrigin(0.5).setInteractive();

    setCoins.on("pointerdown", () => {
        devSetCoins(coinInputValue);
        this.input.keyboard.off("keydown", keyboardHandler);
        this.scene.restart();
    });

    // ===== UNLOCK SKINS =====
    const unlock = this.add.text(400, 340, "UNLOCK ALL SKINS", {
        fontSize: "20px",
        backgroundColor: "#AA8800",
        color: "#ffffff",
        padding: { x: 20, y: 8 }
    }).setOrigin(0.5).setInteractive();

    unlock.on("pointerdown", () => {
        Object.keys(localStorage)
            .filter(k => k.startsWith("skin_"))
            .forEach(k => localStorage.setItem(k, "1"));

        localStorage.setItem("skin_000000", "1");
        localStorage.setItem("skin_FF0000", "1");
        localStorage.setItem("skin_A0522D", "1");

        this.scene.restart();
    });

    // ===== CLOSE =====
    const close = this.add.text(400, 390, "CLOSE", {
        fontSize: "18px",
        backgroundColor: "#AA0000",
        color: "#ffffff",
        padding: { x: 20, y: 6 }
    }).setOrigin(0.5).setInteractive();

    close.on("pointerdown", () => {
        this.input.keyboard.off("keydown", keyboardHandler);
        overlay.destroy();
        box.destroy();
        coinInputBox.destroy();
        coinInputText.destroy();
        setCoins.destroy();
        unlock.destroy();
        close.destroy();
    });
}

async function hashText(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hashBuffer))
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");
}
			
function createPlatform(scene, x, y, widthInPx, heightInPx = 40, color = 0xA0522D) {
    const tileSize = 40;
    const blocksPerRow = Math.floor(widthInPx / tileSize);
    const blocksPerCol = Math.floor(heightInPx / tileSize);

    const isWorld2 = scene.isWorld2 === true;

    for (let row = 0; row < blocksPerCol; row++) {
        for (let col = 0; col < blocksPerRow; col++) {

            const gfx = scene.add.graphics();

            // Bloc principal
            gfx.fillStyle(color, 1);
            gfx.fillRect(0, 0, tileSize, tileSize);

            // ‚ùÑÔ∏è Neige sur le dessus (uniquement World2 et premi√®re rang√©e)
            if (isWorld2 && row === 0) {
                gfx.fillStyle(0xffffff, 1);
                gfx.fillRect(0, 0, tileSize, 8); // √©paisseur de neige
            }

            const key = `block-${x + col * tileSize}-${y + row * tileSize}-${isWorld2 ? "snow" : "normal"}`;
            gfx.generateTexture(key, tileSize, tileSize);
            gfx.destroy();

            const block = scene.platforms.create(x + col * tileSize, y + row * tileSize, key);
            block.setOrigin(0, 0);
            block.refreshBody();
        }
    }
}
function showNotEnoughCoinsPopup(scene) {
    const { width, height } = scene.scale;

    // Fond sombre
    const overlay = scene.add.rectangle(
        width / 2,
        height / 2,
        width,
        height,
        0x000000,
        0.6
    ).setScrollFactor(0);

    // Bo√Æte
    const box = scene.add.rectangle(
        width / 2,
        height / 2,
        360,
        160,
        0x222222
    ).setStrokeStyle(3, 0xffffff);

    // Texte
    const text = scene.add.text(
        width / 2,
        height / 2 - 20,
        "üí∏ Oops! Not enough coins!",
        {
            fontSize: "26px",
            color: "#ffffff"
        }
    ).setOrigin(0.5);

    // Bouton OK
    const okBtn = scene.add.text(
        width / 2,
        height / 2 + 40,
        "OK",
        {
            fontSize: "22px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 20, y: 10 },
            borderRadius: 10
        }
    ).setOrigin(0.5).setInteractive();

    okBtn.on("pointerdown", () => {
        scene.sound.play('menu', { volume: gameVolume });
        overlay.destroy();
        box.destroy();
        text.destroy();
        okBtn.destroy();
    });
}

function createSnow(scene) {
    // Texture flocon
    if (!scene.textures.exists("snowflake")) {
        const gfx = scene.add.graphics();
        gfx.fillStyle(0xffffff, 1);
        gfx.fillCircle(2, 2, 2);
        gfx.generateTexture("snowflake", 4, 4);
        gfx.destroy();
    }

    const particles = scene.add.particles(0, 0, "snowflake", {
        x: { min: 0, max: scene.scale.width },
        y: -10,
        lifespan: 6000,
        speedY: { min: 30, max: 80 },
        speedX: { min: -20, max: 20 },
        scale: { start: 1, end: 0.5 },
        quantity: 4,
        frequency: 100,
        blendMode: "NORMAL"
    });

    particles.setDepth(-10);      // arri√®re-plan
    particles.setScrollFactor(0); // fixe √† l'√©cran
}
function createBlueCircle(scene, x, y) {
    const radius = 20;
    const gfx = scene.add.graphics();
    gfx.fillStyle(0x0000FF, 1);
    gfx.fillCircle(radius, radius, radius);

    const key = `blueCircle-${x}-${y}`;
    gfx.generateTexture(key, radius * 2, radius * 2);
    gfx.destroy();

    const circle = scene.physics.add.sprite(x, y, key);
    circle.setCircle(radius);
    circle.setOrigin(0.5);
    circle.body.allowGravity = false;

    scene.tweens.add({
        targets: circle,
        y: circle.y - 5,
        duration: 800,
        yoyo: true,
        repeat: -1,
        ease: "Sine.easeInOut"
    });

    return circle;
}
function createIcePlatform(scene, x, y, widthInPx, heightInPx = 40) {
    const tileSize = 40;
    const blocksPerRow = Math.floor(widthInPx / tileSize);
    const blocksPerCol = Math.floor(heightInPx / tileSize);

    for (let row = 0; row < blocksPerCol; row++) {
        for (let col = 0; col < blocksPerRow; col++) {

            const gfx = scene.add.graphics();

            // Couleur glace
            gfx.fillStyle(0x9EE7FF, 1);
            gfx.fillRect(0, 0, tileSize, tileSize);

            // Reflet glac√©
            gfx.fillStyle(0xFFFFFF, 0.5);
            gfx.fillRect(0, 0, tileSize, 6);

            const key = `ice-${x}-${y}-${row}-${col}`;
            gfx.generateTexture(key, tileSize, tileSize);
            gfx.destroy();

            const block = scene.icePlatforms.create(
                x + col * tileSize,
                y + row * tileSize,
                key
            );

            block.setOrigin(0, 0);
            block.refreshBody();
        }
    }
}

function createRedTriangle(scene, x, y, orientation = 'up') {
    const size = 40;
    const height = Math.sqrt(3) / 2 * size;
    const key = `triangle-${x}-${y}-${orientation}`;

    const gfx = scene.add.graphics();
    gfx.fillStyle(0xFF0000, 1);
    gfx.beginPath();

    if (orientation === 'up') { gfx.moveTo(size / 2, 0); gfx.lineTo(0, height); gfx.lineTo(size, height); }
    else if (orientation === 'down') { gfx.moveTo(size / 2, height); gfx.lineTo(0, 0); gfx.lineTo(size, 0); }
    else if (orientation === 'left') { gfx.moveTo(0, size / 2); gfx.lineTo(height, 0); gfx.lineTo(height, size); }
    else if (orientation === 'right') { gfx.moveTo(height, size / 2); gfx.lineTo(0, 0); gfx.lineTo(0, size); }

    gfx.closePath();
    gfx.fillPath();

    if (orientation === 'left' || orientation === 'right') gfx.generateTexture(key, height, size);
    else gfx.generateTexture(key, size, height);
    gfx.destroy();

    const triangle = scene.spikes.create(x, y, key);

    switch (orientation) {
        case 'up': triangle.setOrigin(0.5, 1); break;
        case 'down': triangle.setOrigin(0.5, 0); break;
        case 'left': triangle.setOrigin(1, 0.5); break;
        case 'right': triangle.setOrigin(0, 0.5); break;
    }

    triangle.refreshBody();

    const body = triangle.body;
    const bodyWidth = body.width * 0.7;
    const bodyHeight = body.height * 0.7;
    const offsetX = (body.width - bodyWidth) / 2;
    const offsetY = (body.height - bodyHeight) / 2;

    body.setSize(bodyWidth, bodyHeight);
    body.setOffset(offsetX, offsetY);

    return triangle;
}

function createMobileControls(scene) {

  // ‚ùå PC = pas de boutons
  if (!scene.sys.game.device.input.touch) return;

  scene.movingLeft = false;
  scene.movingRight = false;

  const createButtons = () => {

    const { width, height } = scene.scale;

    // Supprimer anciens boutons (resize)
    if (scene.leftBtn) {
      scene.leftBtn.destroy();
      scene.rightBtn.destroy();
      scene.jumpBtn.destroy();
    }

    // Tailles dynamiques
    const btnSize = Math.max(48, width * 0.08);
    const padding = btnSize * 0.4;
    const margin = width * 0.05;

    const btnStyle = {
      fontSize: `${btnSize}px`,
      color: "#ffffff",
      backgroundColor: "#00BFFF",
      padding: { x: padding, y: padding * 0.6 },
      borderRadius: 20
    };

    // Cr√©ation boutons
    scene.leftBtn = scene.add.text(
      margin,
      height - btnSize * 2,
      "‚óÄ",
      btnStyle
    ).setInteractive();

    scene.rightBtn = scene.add.text(
      margin + btnSize * 1.4,
      height - btnSize * 2,
      "‚ñ∂",
      btnStyle
    ).setInteractive();

    scene.jumpBtn = scene.add.text(
      width - margin - btnSize,
      height - btnSize * 2,
      "‚¨Ü",
      btnStyle
    ).setInteractive();

    // Propri√©t√©s communes
    [scene.leftBtn, scene.rightBtn, scene.jumpBtn].forEach(btn => {
      btn.setAlpha(0.6);
      btn.setScrollFactor(0);

      // ‚ú® ANIMATION D‚ÄôAPPUI
      btn.on('pointerdown', () => btn.setAlpha(0.9));
      btn.on('pointerup', () => btn.setAlpha(0.6));
      btn.on('pointerout', () => btn.setAlpha(0.6));
    });

    // D√©placements
    scene.leftBtn.on('pointerdown', () => scene.movingLeft = true);
    scene.leftBtn.on('pointerup', () => scene.movingLeft = false);
    scene.leftBtn.on('pointerout', () => scene.movingLeft = false);

    scene.rightBtn.on('pointerdown', () => scene.movingRight = true);
    scene.rightBtn.on('pointerup', () => scene.movingRight = false);
    scene.rightBtn.on('pointerout', () => scene.movingRight = false);

    // Saut
    scene.jumpBtn.on('pointerdown', () => scene.jumpPlayer());
  };

  // Cr√©ation initiale
  createButtons();

  // üîÅ Auto-resize √©cran / rotation
  scene.scale.on('resize', createButtons);
}
/* =========================================================
                    LOADING SCENE
========================================================= */
class LoadingScene extends Phaser.Scene {
    constructor() {
        super("LoadingScene");
    }

    preload() {
        const { width, height } = this.scale;

        // Texte "Chargement..."
        const loadingText = this.add.text(width / 2, height / 2 - 50, "Chargement...", {
            fontSize: "32px",
            fill: "#ffffff"
        }).setOrigin(0.5);

        // Barre de fond
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(width / 2 - 160, height / 2, 320, 30);

        // Barre de progression
        const progressBar = this.add.graphics();

        // Pourcentage
        const percentText = this.add.text(width / 2, height / 2 + 50, "0%", {
            fontSize: "20px",
            fill: "#ffffff"
        }).setOrigin(0.5);

        // √âv√©nement de progression
        this.load.on('progress', (value) => {
            progressBar.clear();
            progressBar.fillStyle(0xffffff, 1);
            progressBar.fillRect(width / 2 - 150, height / 2 + 5, 300 * value, 20);
            percentText.setText(parseInt(value * 100) + "%");
        });
		this.load.audio('bgm', 'asset/8bit-music-for-game-68698.mp3');
		this.load.audio('jump', 'asset/jump_c_02-102843.mp3');
		this.load.audio('dead', 'asset/game-over-arcade-6435.mp3');
		this.load.audio('victory', 'asset/level-up-enhancement-8-bit-retro-sound-effect-153002.mp3');
		this.load.audio('menu', 'asset/menu.mp3');
		this.load.audio('select', 'asset/select.mp3');
		this.load.audio('kill', 'asset/kill.mp3');
		this.load.audio('buy', 'asset/buy.mp3');
        // Quand le chargement est complet
        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.setText("Pr√™t !");
            percentText.destroy();
        });
	}
		 create() {
        // Lancement du menu apr√®s un petit d√©lai
		this.bgm = this.sound.add('bgm', { loop: true, volume: gameVolume });
        this.time.delayedCall(500, () => {
			if (!this.bgm.isPlaying) this.bgm.play();
            this.scene.start("MenuScene");
        });
    }
}



function createButton(scene, x, y, width, height, label, callback, index = 0) {
    // üîπ Arri√®re-plan avec bordure
    const bg = scene.add.rectangle(x, y + 50, width, height, 0x00BFFF, 0.5)
        .setOrigin(0.5)
        .setStrokeStyle(2, 0xffffff)
        .setInteractive();

    // üîπ Texte
    const text = scene.add.text(x, y + 50, label, {
        fontSize: "28px",
        color: "#ffffff",
        fontStyle: "bold"
    }).setOrigin(0.5);

    // üîπ Tween d‚Äôapparition
    scene.tweens.add({
        targets: [bg, text],
        y: y,
        alpha: { from: 0, to: 1 },
        duration: 700,
        delay: index * 100,
        ease: "Back.easeOut"
    });

    // üîπ Effet hover
    [bg, text].forEach(obj => {
        obj.on("pointerover", () => {
            bg.setFillStyle(0x00BFFF, 0.9);
            text.setStyle({ color: "#00FFFF" });
            scene.tweens.add({ targets: [bg, text], scale: 1.05, duration: 150 });
        });
        obj.on("pointerout", () => {
            bg.setFillStyle(0x00BFFF, 0.5);
            text.setStyle({ color: "#ffffff" });
            scene.tweens.add({ targets: [bg, text], scale: 1, duration: 150 });
        });
        obj.on("pointerdown", () => {
            callback();
            scene.tweens.add({
                targets: [bg, text],
                scale: 0.95,
                duration: 50,
                yoyo: true
            });
        });
    });

    return { bg, text };
}

/* =======================================================
                     MENU SCENE
======================================================= */
class MenuScene extends Phaser.Scene {
    constructor() {
        super("MenuScene");
    }

    create() {
        const { width, height } = this.scale;

        // --- Titre ---
        const title = this.add.text(width / 2, 120, "Jumpix", {
            fontSize: "50px",
            color: "#ffffff",
            fontStyle: "bold"
        }).setOrigin(0.5);

        // --- Coins ---
        this.coinText = this.add.text(width - 20, 20, `üí∞ ${playerCoins}`, {
            fontSize: "28px",
            color: "#ffff00",
            fontStyle: "bold"
        }).setOrigin(1, 0);

        // --- Boutons du menu ---
        const buttons = [
            { label: "‚û° Play !!", scene: "World1" },
            { label: "Shop üõí", scene: "ShopScene" },
            { label: "üèÜ Objectives", scene: "ObjectivesScene" },
            { label: "Statistics", scene: "Stats" },
            { label: "Credits", scene: "CreditsScene" }
        ];

        let startY = 240;
        buttons.forEach((btn, i) => {
            createButton(this, width / 2, startY, 320, 60, btn.label, () => {
                this.sound.play('select', { volume: gameVolume });
                this.scene.start(btn.scene);
            }, i);
            startY += 80;
        });

        // --- Bouton Settings ‚öô ---
        createButton(this, 40, 40, 60, 50, "‚öô", () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("SettingsScene");
        });
    }
}


function createRedCircle(scene, x, y, riseAmount = 100, direction = 'up') {
  const radius = 10;

  const gfx = scene.add.graphics();
  gfx.fillStyle(0xFF0000, 1);
  gfx.fillCircle(radius, radius, radius);
  const key = `redCircle-${x}-${y}`;
  gfx.generateTexture(key, radius * 2, radius * 2);
  gfx.destroy();

  const circle = scene.physics.add.sprite(x, y, key);
  circle.setCircle(radius);
  circle.setOrigin(0.5);
  circle.body.moves = false;
  circle.body.allowGravity = false;
  circle.body.immovable = true;

  const targetY = direction === 'up' ? y - riseAmount : y + riseAmount;

  scene.tweens.add({
    targets: circle,
    y: targetY,
    duration: 2000,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut'
  });

  return circle;
}
function createRedSquare(x, y, scene, distance = 100, direction = 'right') {
  const size = 40;

  // Dessin du carr√© rouge
  const gfx = scene.add.graphics();
  gfx.fillStyle(0xFF0000, 1);
  gfx.fillRect(0, 0, size, size);

  const key = `redSquare-${x}-${y}-${direction}`;
  gfx.generateTexture(key, size, size);
  gfx.destroy();

  const square = scene.physics.add.sprite(x, y, key);
  square.setSize(size, size);
  square.setOrigin(0.5);
  square.body.allowGravity = false;
  square.body.immovable = true;

  // Animation horizontale
  let targetX = x;

  if (direction === 'right') {
    targetX = x + distance;
  } else if (direction === 'left') {
    targetX = x - distance;
  } else {
    console.warn('Direction inconnue pour redSquare :', direction);
  }
  scene.tweens.add({
    targets: square,
    x: targetX,
    duration: 2000,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut'
  });

  return square;
}
/* =========================================================
                        LEVEL
========================================================= */
class LevelScene extends Phaser.Scene {
  constructor() {
    super("LevelScene");
  }

  init(data) {
    this.levelKey = data.levelKey;
  }

preload() {
  this.load.json(this.levelKey, `levels/${this.levelKey}.json`);
}


  create() {
const level = this.cache.json.get(this.levelKey);
if (level.nextScene === "World2") {
    createSnow(this);
}
	this.onIce = false;
	this.isWorld2 = (level.nextScene === "World2");
    this.transitioning = false;
    this.platforms = this.physics.add.staticGroup();
    this.spikes = this.physics.add.staticGroup();
    this.redCircles = this.physics.add.group();
	this.redSquares = this.physics.add.group();
	this.icePlatforms = this.physics.add.staticGroup();

    this.input.addPointer(2);
    this.cursors = this.input.keyboard.createCursorKeys();
    this.jumpCount = 0;

    // --- PLATEFORMES ---
    level.platforms.forEach(p => {
	  const color = typeof p.color === "string" ? parseInt(p.color) : (p.color || 0xA0522D);
      createPlatform(this, p.x, p.y, p.w, p.h || 40, color || 0xA0522D)
	});

    // --- PIQUES ---
    level.spikes.forEach(s =>
      createRedTriangle(this, s.x, s.y, s.orientation || "up")
    );

    // --- BOULES ROUGES ---
    if (level.redCircles) {
      level.redCircles.forEach(c =>
        this.redCircles.add(createRedCircle(
          this,
          c.x,
          c.y,
          c.rise,
          c.direction || "up"
        ))
      );
    }
    // --- CARRES ---
	if (level.redSquares) {
      level.redSquares.forEach(r =>
        this.redSquares.add(createRedSquare(
          r.x,
          r.y,
		  this,
          r.rise,
          r.direction
        ))
      );
    }
    // --- JOUEUR ---
    const size = 40;
    const gfx = this.add.graphics();
    gfx.fillStyle(colorPlayer, 1);
    gfx.fillRect(0, 0, size, size);
    gfx.generateTexture("player", size, size);
    gfx.destroy();

    this.player = this.physics.add.sprite(
      level.playerStart.x,
      level.playerStart.y,
      "player"
    );

    this.player.setBounce(0.2).setCollideWorldBounds(true);

	// --- PLATEFORMES DE GLACE ---
if (level.icePlatforms) {
    level.icePlatforms.forEach(p => {
        createIcePlatform(this, p.x, p.y, p.w, p.h || 40);
    });
}


    // --- SORTIE ---
    this.blueCircle = createBlueCircle(
      this,
      level.blueCircle.x,
      level.blueCircle.y
    );
	// --- Bouton "Retour" ---
const backButton = this.add.text(5, 5, "‚Üê", {
    fontSize: "24px",
    color: "#ffffff",
    backgroundColor: "#00BFFF",
    padding: { x: 7, y: 4 },
    borderRadius: 5
}).setInteractive();

// √âv√©nement au clic sur le bouton
backButton.on("pointerdown", () => {
    // Jouer le son du menu
    this.sound.play('menu', { volume: gameVolume });

    // Retour √† la sc√®ne "World1"
    this.scene.start(level.nextScene);
});

    // --- COLLISIONS ---
    this.physics.add.collider(this.player, this.platforms);
	this.physics.add.collider(this.player, this.icePlatforms, (player, ice) => {
    	this.onIce = true;
	}, null, this);
	this.physics.add.collider(this.redSquares, this.platforms);
    this.physics.add.collider(this.player, this.spikes, () => this.die());
    this.physics.add.overlap(this.player, this.redCircles, () => this.die());
	this.physics.add.overlap(this.player, this.redSquares, (player, square) => {
  const playerBottom = player.y + player.displayHeight / 2;
  const squareTop = square.y - square.displayHeight / 2;

  const verticalDiff = playerBottom - squareTop;

  // Si le joueur touche par le haut (avec une petite marge de tol√©rance)
  if (verticalDiff < 10 && player.body.velocity.y > 0) {
    // Le joueur a saut√© sur le carr√© rouge
	kill++;
	localStorage.setItem("kill", kill);
	checkObjectives()
	this.sound.play("kill", { volume: gameVolume });
    player.setVelocityY(-200);
    this.tweens.add({
      targets: square,
      scaleX: 0,
      scaleY: 0,
      duration: 300,
      ease: 'Cubic.easeIn',
      onComplete: () => {
        square.destroy();
      }
    });
    } else {
	  dead++;
	localStorage.setItem("dead", dead);
	checkObjectives()
    this.sound.play("dead", { volume: gameVolume });
    this.scene.restart();
  }
  }, null, this);

	this.physics.add.overlap(this.player, this.blueCircle, () => {
    // Jouer le son de victoire
    this.sound.play('victory', { volume: gameVolume });
	party++;
	localStorage.setItem("party", party);
	checkObjectives()
    // V√©rifier si une transition est d√©j√† en cours
    if (this.transitioning) return;
    this.transitioning = true;

    // D√©sactiver le mouvement du joueur
    this.player.body.enable = false;

    // D√©finir la position cible pour l'animation
    const targetX = this.blueCircle.x;
    const targetY = this.blueCircle.y;

    // Ajouter l'animation de transition du joueur
    this.tweens.add({
        targets: this.player,
        x: targetX,
        y: targetY,
        scale: 0.3,
        angle: 720,
        duration: 800,
        ease: 'Cubic.easeInOut',
        onComplete: () => {


            // Ajouter des pi√®ces au joueur
            playerCoins += level.reward || 0;
            localStorage.setItem("playerCoins", playerCoins);
            // Changer de sc√®ne
            this.scene.start(level.nextScene);
        }
    });
}, null, this);
    createMobileControls(this);
  }

  die() {
    this.sound.play("dead", { volume: gameVolume });
	dead++;
	localStorage.setItem("dead", dead);
	checkObjectives()
    this.scene.restart({ levelKey: this.levelKey });
  }

update() {
const p = this.player;

if (p.body.touching.down && this.onIce) {
    // si on commence √† glisser
    if (!this.sliding) {
        this.sliding = true;
        // d√©terminer direction initiale
        this.slideDir = p.body.velocity.x !== 0 ? Math.sign(p.body.velocity.x) : (this.cursors.right.isDown ? 1 : -1);
    }

    // appliquer vitesse constante
    p.setVelocityX(220 * this.slideDir);

} else {
    // si on quitte la glace
    this.sliding = false;

    // contr√¥les normaux
    if (this.cursors.left.isDown || this.movingLeft) p.setVelocityX(-160);
    else if (this.cursors.right.isDown || this.movingRight) p.setVelocityX(160);
    else p.setVelocityX(0);
}

// reset flag glace √† la fin du frame
this.onIce = false;

    // --- Reset compteur de saut si le joueur touche le sol ---
    if (p.body.touching.down) {
        this.jumpCount = 0;
    }

    // --- Saut via clavier ---
    if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {
        this.jumpPlayer();
    }
}

// --- Fonction saut + double saut ---
jumpPlayer() {
    if (this.jumpCount < 2) {
        // Appliquer la v√©locit√© verticale pour le saut
        this.player.setVelocityY(-330);

        // Si c'est le deuxi√®me saut, ajouter une rotation
        if (this.jumpCount === 1) {
            const dir = this.cursors.left.isDown ? -1 : (this.cursors.right.isDown ? 1 : 1);

            this.tweens.add({
                targets: this.player,
                angle: this.player.angle + 180 * dir,
                duration: 500,
                ease: "Cubic.easeOut"
            });
        }

        // Jouer le son du saut
        this.sound.play('jump', { volume: gameVolume });

        // Incr√©menter le compteur de saut
        this.jumpCount++;
    }
}
}
/* =====================================================
                    Shop
   ===================================================== */
function normalizeKeyToHex(key) {
    if (typeof key === "number") {
        return key.toString(16).toUpperCase().padStart(6, "0");
    }

    key = String(key).trim();

    if (key.startsWith("0x") || key.startsWith("0X")) key = key.slice(2);
    if (key.startsWith("#")) key = key.slice(1);

    return key.toUpperCase();
}

// ----------- SHOP SCENE -----------
class ShopScene extends Phaser.Scene {
    constructor() {
        super("ShopScene");
    }

    preload() {}

    create() {

        this.add.text(360, 20, "SHOP", { fontSize: "40px", fill: "#ffffff" });
       this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite

        const ITEMS = [
            { key: "AA66CC", label: "Purple", price: 0 },
            { key: "73BE73", label: "Green", price: 50 },
            { key: "CC99A2", label: "Pink", price: 100 },
			{ key: "40E0D0", label: "Turquoise", price: 150 },
			{ key: "FFA500", label: "Orange", price: 200 }
        ];

        let startY = 150;

        ITEMS.forEach(item => {
            const hexKey = normalizeKeyToHex(item.key);
            const bought = localStorage.getItem("skin_" + hexKey) === "1";
			const isSelected = parseInt(localStorage.getItem("colorPlayer")) === parseInt("0x" + hexKey);

            this.add.rectangle(80, startY, 50, 50, parseInt("0x" + hexKey));

            this.add.text(140, startY - 20, item.label, { fontSize: "24px", fill: "#ffffff" });

            if (!bought && item.price > 0) {
                const buyText = this.add.text(350, startY - 20, "Buy " + item.price + " ‚¨°", { fontSize: "22px", fill: "#00FFFF" });
                buyText.setInteractive();

                buyText.on("pointerdown", () => {
					this.sound.play('buy', { volume: gameVolume })
					this.buySkin(hexKey, item.price);
				})
            }

            if (bought || item.price === 0) {
                const selectText = this.add.text(350, startY - 20, isSelected ? "selected" : "select", {
                    fontSize: "22px",
                    fill: isSelected ? "#00FF66" : "#FFFFFF"
                });
                selectText.setInteractive();

                selectText.on("pointerdown", () => {
					this.sound.play('select', { volume: gameVolume })
					this.selectSkin(hexKey);
				})
            }

            startY += 90;
        });

        const back = this.add.text(5, 5, "‚Üê", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        back.setInteractive();
        back.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
		const next = this.add.text(700, 280, "‚ñ∂", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        next.setInteractive();
        next.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("ShopScene2");
        });
    }

    buySkin(colorKey, price) {
        if (playerCoins < price) {
            showNotEnoughCoinsPopup(this);
            return;
        }

        playerCoins -= price;
        localStorage.setItem("playerCoins", playerCoins);

        localStorage.setItem("skin_" + colorKey, "1");
        this.scene.restart();
    }

selectSkin(colorKey) {
    const colorNumber = parseInt("0x" + colorKey);

    localStorage.setItem("colorPlayer", colorNumber);
    colorPlayer = colorNumber;

    this.scene.restart();
}
}
			// ----------- SHOP SCENE 2 -----------
class ShopScene2 extends Phaser.Scene {
    constructor() {
        super("ShopScene2");
    }

    preload() {}

    create() {

        this.add.text(360, 20, "SHOP", { fontSize: "40px", fill: "#ffffff" });
       this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite

        const ITEMS = [
            { key: "7A0000", label: "Maroon", price: 250 },
			{ key: "0B228A", label: "Dark Blue", price: 300 },
			{ key: "226546", label: "Dark Green", price: 350 },
			{ key: "E2FF00", label: "Yellow", price: 400 },
			{ key: "FFEADD", label: "Inna Beige", price: 450 }
        ];

        let startY = 150;

        ITEMS.forEach(item => {
            const hexKey = normalizeKeyToHex(item.key);
            const bought = localStorage.getItem("skin_" + hexKey) === "1";
			const isSelected = parseInt(localStorage.getItem("colorPlayer")) === parseInt("0x" + hexKey);

            this.add.rectangle(80, startY, 50, 50, parseInt("0x" + hexKey));

            this.add.text(140, startY - 20, item.label, { fontSize: "24px", fill: "#ffffff" });

            if (!bought && item.price > 0) {
                const buyText = this.add.text(350, startY - 20, "Buy " + item.price + " ‚¨°", { fontSize: "22px", fill: "#00FFFF" });
                buyText.setInteractive();

                buyText.on("pointerdown", () => {
					this.sound.play('buy', { volume: gameVolume })
					this.buySkin(hexKey, item.price);
				})
            }

            if (bought || item.price === 0) {
                const selectText = this.add.text(350, startY - 20, isSelected ? "selected" : "select", {
                    fontSize: "22px",
                    fill: isSelected ? "#00FF66" : "#FFFFFF"
                });
                selectText.setInteractive();

                selectText.on("pointerdown", () => {
					this.sound.play('select', { volume: gameVolume })
					this.selectSkin(hexKey);
				})
            }

            startY += 90;
        });

        const back = this.add.text(5, 5, "‚Üê", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        back.setInteractive();
        back.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
		const prec = this.add.text(10, 280, "‚óÄ", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        prec.setInteractive();
        prec.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("ShopScene");
        });
    }

    buySkin(colorKey, price) {
        if (playerCoins < price) {
            showNotEnoughCoinsPopup(this);
            return;
        }

        playerCoins -= price;
        localStorage.setItem("playerCoins", playerCoins);

        localStorage.setItem("skin_" + colorKey, "1");
        this.scene.restart();
    }

selectSkin(colorKey) {
    const colorNumber = parseInt("0x" + colorKey);

    localStorage.setItem("colorPlayer", colorNumber);
    colorPlayer = colorNumber;

    this.scene.restart();
}
}
/* =========================================================
                       World 1
========================================================= */

class World1 extends Phaser.Scene {
    constructor() {
        super("World1");
    }

    create() {
		
        const title = this.add.text(400, 80, "World 1", {
            fontSize: "50px",
            color: "#ffffffff"
        }).setOrigin(0.5);
		this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite
		const MenuButton = this.add.text(5, 5, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        MenuButton.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
		/*const next = this.add.text(700, 280, "‚ñ∂", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        next.setInteractive();
        next.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("World2");
        });*/
		
        const niveaux1 = [
            { nom: "‚û° Level 1", scene: "Level1" },
            { nom: "‚û° Level 2", scene: "Level2" },
            { nom: "‚û° Level 3", scene: "Level3" },
            { nom: "‚û° Level 4", scene: "Level4" }
        ];

        let yPos1 = 260;
        niveaux1.forEach(niv => {
            const btn = this.add.text(200, yPos1, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})
            yPos1 += 60; // √©cart vertical entre boutons
        });
		        const niveaux2 = [
            { nom: "‚û° Level 5", scene: "Level5" },
			{ nom: "‚û° Level 6", scene: "Level6" },
			{ nom: "‚û° Level 7", scene: "Level7" },
			{ nom: "‚û° Level 8", scene: "Level8" }
        ];

        let yPos2 = 260;
        niveaux2.forEach(niv => {
            const btn = this.add.text(550, yPos2, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})

            yPos2 += 60; // √©cart vertical entre boutons
        });
    }
}
/*======================================================
                   Setting
=======================================================*/
class SettingsScene extends Phaser.Scene {
    constructor() {
        super("SettingsScene");
    }

    create() {
        this.add.text(400, 80, "Settings", {
            fontSize: "40px",
            color: "#ffffff"
        }).setOrigin(0.5);

        this.add.text(400, 160, "Volume", {
            fontSize: "28px",
            color: "#ffffff"
        }).setOrigin(0.5);

        // Barre de fond
        const barBg = this.add.rectangle(400, 220, 300, 10, 0x555555);

        // Curseur
        const knob = this.add.circle(
            400 - 150 + gameVolume * 300,
            220,
            12,
            0xffffff
        ).setInteractive({ draggable: true });

        this.input.setDraggable(knob);

        this.input.on('drag', (pointer, obj, dragX) => {
            const minX = 400 - 150;
            const maxX = 400 + 150;

            obj.x = Phaser.Math.Clamp(dragX, minX, maxX);

            gameVolume = (obj.x - minX) / 300;
            gameVolume = Phaser.Math.Clamp(gameVolume, 0, 1);

            localStorage.setItem("gameVolume", gameVolume);

            this.sound.volume = gameVolume;
        });
		// ===== Bouton RESET COMPTE =====
const resetBtn = this.add.text(400, 320, "RESET ACCOUNT", {
    fontSize: "24px",
    color: "#ffffff",
    backgroundColor: "#FF4444",
    padding: { x: 20, y: 10 },
    borderRadius: 8
}).setOrigin(0.5).setInteractive();

resetBtn.on("pointerdown", () => {
    this.sound.play('menu', { volume: gameVolume });

    // Confirmation
    const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.6);
    const box = this.add.rectangle(400, 300, 360, 180, 0x222222)
        .setStrokeStyle(3, 0xffffff);

    const txt = this.add.text(400, 260,
        "Reset all progress?\nThis cannot be undone!",
        { fontSize: "20px", color: "#ffffff", align: "center" }
    ).setOrigin(0.5);

    const yes = this.add.text(340, 340, "YES", {
        fontSize: "22px",
        backgroundColor: "#FF4444",
        padding: { x: 15, y: 8 }
    }).setOrigin(0.5).setInteractive();

    const no = this.add.text(460, 340, "NO", {
        fontSize: "22px",
        backgroundColor: "#00BFFF",
        padding: { x: 15, y: 8 }
    }).setOrigin(0.5).setInteractive();

    no.on("pointerdown", () => {
        overlay.destroy(); box.destroy(); txt.destroy(); yes.destroy(); no.destroy();
    });

    yes.on("pointerdown", () => {
        // üî• RESET TOTAL
        localStorage.clear();

        // Valeurs par d√©faut
        localStorage.setItem("gameVolume", 0.5);
        localStorage.setItem("playerCoins", 0);
        localStorage.setItem("dead", 0);
        localStorage.setItem("kill", 0);
        localStorage.setItem("party", 0);
        localStorage.setItem("colorPlayer", 0xAA66CC);

        // Variables runtime
        gameVolume = 0.5;
        playerCoins = 0;
        dead = 0;
        kill = 0;
        party = 0;
        colorPlayer = 0xAA66CC;

        this.scene.start("MenuScene");
    });
});

// ===== Bouton DEV MENU =====
const devBtn = this.add.text(400, 380, "DEV MENU", {
    fontSize: "22px",
    color: "#ffffff",
    backgroundColor: "#4444AA",
    padding: { x: 25, y: 10 },
    borderRadius: 8
}).setOrigin(0.5).setInteractive();
devBtn.on("pointerdown", () => {
    this.sound.play('menu', { volume: gameVolume });

    // ===== POPUP PASSWORD =====
    const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
    const box = this.add.rectangle(400, 300, 400, 240, 0x222222).setStrokeStyle(3, 0xffffff);

    const title = this.add.text(400, 240, "DEV PASSWORD", {
        fontSize: "24px",
        color: "#ffffff"
    }).setOrigin(0.5);

    let inputText = "";
    const input = this.add.text(400, 295, "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢", {
        fontSize: "26px",
        color: "#00ffcc",
        backgroundColor: "#000000",
        padding: { x: 15, y: 8 }
    }).setOrigin(0.5);

    const info = this.add.text(400, 335, "", {
        fontSize: "18px",
        color: "#ff5555"
    }).setOrigin(0.5);
	const closeBtn = this.add.text(400, 365, "CANCEL", {
    fontSize: "18px",
    backgroundColor: "#aa0000",
    color: "#ffffff",
    padding: { x: 20, y: 6 }
})
.setOrigin(0.5)
.setInteractive();
closeBtn.on("pointerdown", () => {
    this.sound.play('menu', { volume: gameVolume });
    destroyPasswordPopup();
});

    const destroyPasswordPopup = () => {
        overlay.destroy();
        box.destroy();
        title.destroy();
        input.destroy();
        info.destroy();
		closeBtn.destroy();
        this.input.keyboard.removeAllListeners();
    };

    this.input.keyboard.on('keydown', async (event) => {
        if (event.key === "Backspace") {
            inputText = inputText.slice(0, -1);
        } else if (event.key === "Enter") {

            const hashed = await hashText(inputText);

            if (hashed === DEV_PASSWORD_HASH) {
                destroyPasswordPopup();
                openDevMenu.call(this);
            } else {
                info.setText("‚ùå Wrong password");
                inputText = "";
            }
        } else if (event.key.length === 1) {
            inputText += event.key;
        }

        input.setText("‚Ä¢".repeat(inputText.length));
    });
});


        // Bouton retour
      		const backButton = this.add.text(5, 5, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        backButton.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
    })
}
}
/* =========================================================
                     Cr√©dits
========================================================= */
class CreditsScene extends Phaser.Scene {
    constructor() {
        super("CreditsScene");
    }

    create() {
        const { width, height } = this.scale;
        // Contenu des cr√©dits
        const credits = [
			"Credits",
			"",
            "A game by",
            "OneLevel Studio",
            "",
            "Producer & Lead Programmer",
            "Eliott MORBIDELLI",
            "",
            "Visual Designer",
            "Leonie MORBIDELLI",
            "",
            "Lead Level Designer",
            "Eliott MORBIDELLI",
            "",
            "Level Designers",
            "A. MORBIDELLI",
			"Alix MORBIDELLI",
            "",
            "QA Testers",
            "Maxence ROSS",
            "",
            "Thanks for playing!",
			"",
			"For Inna"
        ];

        // Cr√©er un conteneur pour tous les textes
        this.creditContainer = this.add.container(width / 2, height + 50);

        let offsetY = 0;
        credits.forEach(line => {
            const text = this.add.text(0, offsetY, line, {
                fontSize: "28px",
                color: "#ffffff"
            }).setOrigin(0.5);
            this.creditContainer.add(text);
            offsetY += 50; // espacement entre les lignes
        });

        // Vitesse de d√©filement (pixels par seconde)
        this.scrollSpeed = 50;

        // √âv√©nement clic partout sur la sc√®ne
        this.input.once('pointerdown', () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("MenuScene");
        });
    }

    update(time, delta) {
        // Faire d√©filer les cr√©dits vers le haut
        this.creditContainer.y -= this.scrollSpeed * (delta / 1000);

        // Si le dernier texte est pass√© au-dessus de l'√©cran, revenir au menu automatiquement
        const lastText = this.creditContainer.list[this.creditContainer.list.length - 1];
        if (lastText.y + this.creditContainer.y < -50) {
            this.scene.start("MenuScene");
        }
    }
}
/* ========================================================
                           Stats
========================================================= */
class Stats extends Phaser.Scene {
    constructor() {
        super("Stats");
    }

    create() {
        const { width, height } = this.scale;

        // Fond
        this.add.rectangle(width / 2, height / 2, width, height, 0x3d2505);

        // Titre
        this.add.text(width / 2, 60, "STATISTICS", {
            fontSize: "40px",
            color: "#ffffff",
            fontStyle: "bold"
        }).setOrigin(0.5);

        // R√©cup√©ration des stats
        const coins = parseInt(localStorage.getItem("playerCoins")) || 0;
        const deaths = parseInt(localStorage.getItem("dead")) || 0;
        const kills = parseInt(localStorage.getItem("kill")) || 0;
        const parties = parseInt(localStorage.getItem("party")) || 0;

        // Affichage
        const statsData = [
            { label: "Coins üí∞", value: coins },
            { label: "Deaths ‚ò†Ô∏è", value: deaths },
            { label: "Kills üî™", value: kills },
            { label: "Parties Played üéÆ", value: parties }
        ];

        let startY = 150;
        statsData.forEach(stat => {
            this.add.text(width / 2, startY, `${stat.label} : ${stat.value}`, {
                fontSize: "28px",
                color: "#ffff00"
            }).setOrigin(0.5);
            startY += 60;
        });

        // Bouton retour
        const backButton = this.add.text(10, 10, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 10, y: 5 },
            borderRadius: 5
        }).setInteractive();

        backButton.on("pointerdown", () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("MenuScene");
        });
	}
}
/* ========================================================
                           World 2
========================================================= */
class World2 extends Phaser.Scene {
    constructor() {
        super("World2");
    }

    create() {
		createSnow(this);
        const title = this.add.text(400, 80, "World 2", {
            fontSize: "50px",
            color: "#ffffffff"
        }).setOrigin(0.5);
		this.coinText = this.add.text(780, 20, `üí∞ ${playerCoins}`, {
    		fontSize: "28px",
    		color: "#ffff00"
		}).setOrigin(1, 0); // align√© √† droite
		const MenuButton = this.add.text(5, 5, "‚Üê", {
            fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        }).setInteractive();

        MenuButton.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("MenuScene");
        });
				const prec = this.add.text(10, 280, "‚óÄ", {
           fontSize: "24px",
            color: "#ffffff",
            backgroundColor: "#00BFFF",
            padding: { x: 7, y: 4 },
            borderRadius: 5
        });
        prec.setInteractive();
        prec.on("pointerdown", () => {
			this.sound.play('menu', { volume: gameVolume })
            this.scene.start("World1");
        });
        const niveaux3 = [
            { nom: "‚û° Level 9", scene: "Level9" }
        ];

        let yPos1 = 260;
        niveaux3.forEach(niv => {
            const btn = this.add.text(200, yPos1, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})
            yPos1 += 60; // √©cart vertical entre boutons
        });
		        const niveaux4 = [
        ];

        let yPos2 = 260;
        niveaux4.forEach(niv => {
            const btn = this.add.text(550, yPos2, niv.nom, {
                fontSize: "34px",
                color: "#ffffffff"
            }).setOrigin(0.5).setInteractive();

            btn.on("pointerdown", () => {
				this.sound.play('select', { volume: gameVolume })
				this.scene.start("LevelScene", {
  					levelKey: niv.scene
				});
			})

            yPos2 += 60; // √©cart vertical entre boutons
        });
    }
}
/*===============================================================
						Objectifs
================================================================*/
class ObjectivesScene extends Phaser.Scene {
    constructor() {
        super("ObjectivesScene");
    }

    create() {
        checkObjectives();

        const { width } = this.scale;

        this.add.text(width / 2, 60, "OBJECTIVES", {
            fontSize: "40px",
            color: "#ffffff"
        }).setOrigin(0.5);

        const deadCount = parseInt(localStorage.getItem("dead")) || 0;
        const killCount = parseInt(localStorage.getItem("kill")) || 0;
        const levelsDone = parseInt(localStorage.getItem("party")) || 0;
const objectives = [
    {
        label: "‚ò†Ô∏è Die 1000 times",
        progress: deadCount,
        goal: 1000,
        skin: "000000",
        color: 0x000000
    },
    {
        label: "üî™ Make 500 kills",
        progress: killCount,
        goal: 500,
        skin: "FF0000",
        color: 0xFF0000
    },
    {
        label: "üéÆ Complete 1000 levels",
        progress: levelsDone,
        goal: 1000,
        skin: "A0522D",
        color: 0xA0522D
    }
];


        let y = 150;

        objectives.forEach(obj => {

            const unlocked = localStorage.getItem("skin_" + obj.skin) === "1";
            const percent = Math.min(obj.progress / obj.goal, 1);

            // Texte objectif
            this.add.text(100, y, obj.label, {
                fontSize: "22px",
                color: "#ffffff"
            });

            // Barre de progression
            this.add.rectangle(100, y + 30, 300, 12, 0x444444).setOrigin(0);
            this.add.rectangle(100, y + 30, 300 * percent, 12, unlocked ? 0x00FF66 : 0xFFD700).setOrigin(0);

            // Progression
            this.add.text(420, y + 20, `${obj.progress}/${obj.goal}`, {
                fontSize: "18px",
                color: "#ffffff"
            });

            // Skin preview
            const skinBox = this.add.rectangle(600, y + 20, 40, 40, obj.color);

            if (unlocked) {
      const isSelected = colorPlayer === obj.color;
        const select = this.add.text(660, y + 10, isSelected ? "Selected" : "Select", {
            fontSize: "18px",
            color: isSelected ? "#00FF66" : "#ffffff",
            backgroundColor: "#ADD8E6",
            padding: { x: 10, y: 5 },
            borderRadius: 5
        }).setInteractive();

        select.on("pointerdown", () => {
            this.sound.play('select', { volume: gameVolume });
            localStorage.setItem("colorPlayer", obj.color);
            colorPlayer = obj.color;
			localStorage.setItem("colorPlayer", colorPlayer);
            // Mettre √† jour le texte du bouton pour refl√©ter la s√©lection
            select.setText("Selected");
            select.setColor("#00FF66");
        });
            } else {
                this.add.text(660, y + 10, "üîí", { fontSize: "22px" });
            }

            y += 100;
        });

        // Bouton retour
        const back = this.add.text(10, 10, "‚Üê", {
            fontSize: "24px",
            backgroundColor: "#00BFFF",
            padding: { x: 10, y: 5 }
        }).setInteractive();

        back.on("pointerdown", () => {
            this.sound.play('menu', { volume: gameVolume });
            this.scene.start("MenuScene");
        });
    }
}

/* =========================================================
                    CONFIG JEU
========================================================= */
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#ADD8E6',
  physics: { default: 'arcade', arcade: { gravity: { y: 650 }, debug: false } },
   scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
   },
  scene: [LoadingScene, MenuScene,  LevelScene, ShopScene, ShopScene2, World1, SettingsScene, CreditsScene, Stats, World2, ObjectivesScene]
};

const game = new Phaser.Game(config);
		</script>
    </body>
</html>


